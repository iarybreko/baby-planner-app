<!doctype html>
<html lang="en" class="">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Baby Day Planner</title>
    <script>
      // Apply saved theme before paint
      (function(){
        try {
          const saved = localStorage.getItem("bp_theme");
          if (saved === "dark") document.documentElement.classList.add("dark");
        } catch(e){}
      })();
    </script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        darkMode: 'class'
      }
    </script>
    <style>
      input[type="time"]{min-width:90px}
      .chip{font-size:.7rem;letter-spacing:.04em}
    </style>
  </head>
  <body class="min-h-screen bg-slate-50 text-slate-800 dark:bg-slate-950 dark:text-slate-100">
    <div id="root"></div>

    <!-- React 18 UMD -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

    <script>
      // Helpers
      const addMinutes = (d, m) => new Date(d.getTime() + m * 60000);
      const addHours = (d, h) => addMinutes(d, h * 60);
      const differenceInMinutes = (a, b) => Math.round((a.getTime() - b.getTime()) / 60000);
      const isBefore = (a, b) => a.getTime() < b.getTime();
      const startOfDay = (d) => { const x = new Date(d); x.setHours(0,0,0,0); return x; };
      const parseISO = (s) => new Date(s);
      const pad2 = (n) => String(n).padStart(2,"0");
      const formatHHmm = (d) => `${pad2(d.getHours())}:${pad2(d.getMinutes())}`;
      const timeToDate = (baseDate, hhmm) => {
        const [hh, mm] = hhmm.split(":").map(Number);
        const nd = new Date(baseDate);
        nd.setHours(hh, mm ?? 0, 0, 0);
        return nd;
      };
      const { useEffect, useRef, useState } = React;

      const uid = () => Math.random().toString(36).slice(2, 10);
      const toLocalInput = (d) => `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}T${pad2(d.getHours())}:${pad2(d.getMinutes())}`;
      const fromLocalInput = (s) => new Date(s);
      const clampToToday = (d) => { const today = startOfDay(new Date()); return d < today ? today : d; };
      const minutesUntil = (d) => Math.max(0, Math.round((d.getTime() - Date.now()) / 60000));
      const sortEvents = (arr) => [...arr].sort((a,b)=> a.start - b.start);

      // Build schedule
      function buildSchedule({ firstWake, firstFeed, bedtime, feedEveryHours, napEveryHours, napDurationMinutes }) {
        const events = [];
        for (let t = new Date(firstFeed); isBefore(t, bedtime); t = addHours(t, feedEveryHours)) {
          events.push({ id: uid(), type: "feed", start: new Date(t), completed: false, ml: null });
        }
        let napStart = addHours(firstWake, napEveryHours);
        let napEnd = addMinutes(napStart, napDurationMinutes);
        while (isBefore(napStart, bedtime)) {
          events.push({ id: uid(), type: "nap", start: new Date(napStart), end: new Date(napEnd), completed: false });
          napStart = addHours(napEnd, napEveryHours);
          napEnd = addMinutes(napStart, napDurationMinutes);
        }
        return sortEvents(events);
      }

      // Shift only following items of the same type by deltaMinutes
      function shiftFollowingSameType(events, index, deltaMinutes) {
        const targetType = events[index].type;
        const shifted = events.map((e, i) => {
          if (i <= index) return e;
          if (e.type !== targetType) return e;
          const start = addMinutes(e.start, deltaMinutes);
          const end = e.end ? addMinutes(e.end, deltaMinutes) : undefined;
          return { ...e, start, end };
        });
        return sortEvents(shifted);
      }

      function saveState(state) {
        localStorage.setItem("babyPlannerState", JSON.stringify({
          ...state,
          firstWake: state.firstWake.toISOString(),
          firstFeed: state.firstFeed.toISOString(),
          bedtime: state.bedtime.toISOString(),
          events: state.events.map(e => ({
            ...e,
            start: e.start.toISOString(),
            end: e.end ? e.end.toISOString() : undefined,
          })),
        }));
      }

      function loadState() {
        try {
          const raw = localStorage.getItem("babyPlannerState");
          if (!raw) return null;
          const parsed = JSON.parse(raw);
          return {
            ...parsed,
            firstWake: parseISO(parsed.firstWake),
            firstFeed: parseISO(parsed.firstFeed),
            bedtime: parseISO(parsed.bedtime),
            events: sortEvents(parsed.events.map(e => ({
              ...e,
              start: parseISO(e.start),
              end: e.end ? parseISO(e.end) : undefined,
              completed: !!e.completed,
              ml: (e.ml === undefined ? null : e.ml)
            }))),
          };
        } catch { return null; }
      }

      function ensureNotificationPermission() {
        if (!("Notification" in window)) return Promise.resolve("unsupported");
        if (Notification.permission === "granted") return Promise.resolve("granted");
        if (Notification.permission === "denied") return Promise.resolve("denied");
        return Notification.requestPermission();
      }

      function scheduleLocalNotifs(events) {
        const timers = [];
        for (const e of events) {
          if (e.completed) continue;
          const title = e.type === "feed" ? "Feed" : "Nap";
          const when = addMinutes(e.start, -5);
          const ms = when.getTime() - Date.now();
          if (ms > 0 && ms < 1000 * 60 * 60 * 24) {
            const id = window.setTimeout(() => {
              if ("Notification" in window && Notification.permission === "granted") {
                const body = `${title} at ${formatHHmm(e.start)}`;
                new Notification("Reminder", { body });
              }
            }, ms);
            timers.push(id);
          }
        }
        return () => timers.forEach(clearTimeout);
      }

      function generateICS(events) {
        const dtstamp = `${(new Date()).toISOString().replace(/[-:]/g,'').replace(/\.\d{3}Z/,'Z')}`;
        const lines = ["BEGIN:VCALENDAR","VERSION:2.0","PRODID:-//BabyPlanner//EN"];
        for (const e of events) {
          const uidStr = `${e.id}@babyplanner`;
          const start = `${e.start.getFullYear()}${pad2(e.start.getMonth()+1)}${pad2(e.start.getDate())}T${pad2(e.start.getHours())}${pad2(e.start.getMinutes())}00`;
          const defaultEnd = e.type === "nap" ? addMinutes(e.start, 60) : addMinutes(e.start, 20);
          const endDate = e.end || defaultEnd;
          const end = `${endDate.getFullYear()}${pad2(endDate.getMonth()+1)}${pad2(endDate.getDate())}T${pad2(endDate.getHours())}${pad2(endDate.getMinutes())}00`;
          const summary = e.type === "feed" ? "Feed" : "Nap";
          lines.push(
            "BEGIN:VEVENT",
            `UID:${uidStr}`,
            `DTSTAMP:${dtstamp}`,
            `DTSTART:${start}`,
            `DTEND:${end}`,
            `SUMMARY:${summary}`,
            "BEGIN:VALARM",
            "TRIGGER:-PT5M",
            "ACTION:DISPLAY",
            `DESCRIPTION:${summary} in 5 minutes`,
            "END:VALARM",
            "END:VEVENT"
          );
        }
        lines.push("END:VCALENDAR");
        return lines.join("\r\n");
      }

      function App() {
        const now = new Date();
        const saved = loadState();

        const [firstWake, setFirstWake] = useState(saved?.firstWake || clampToToday(now));
        const [firstFeed, setFirstFeed] = useState(saved?.firstFeed || addMinutes(clampToToday(now), 15));
        const [bedtime, setBedtime] = useState(saved?.bedtime || (() => { const d = new Date(now); d.setHours(19,0,0,0); return d; })());
        const [feedEvery, setFeedEvery] = useState(saved?.feedEvery || 4);
        const [napEvery, setNapEvery] = useState(saved?.napEvery || 2);
        const [napDuration, setNapDuration] = useState(saved?.napDuration || 60);
        const [events, setEvents] = useState(saved?.events || []);
        const [notifStatus, setNotifStatus] = useState("unknown");
        const [theme, setTheme] = useState(() => {
          try { return localStorage.getItem("bp_theme") || "light"; } catch { return "light"; }
        });

        // Apply theme
        useEffect(() => {
          const root = document.documentElement;
          if (theme === "dark") root.classList.add("dark"); else root.classList.remove("dark");
          try { localStorage.setItem("bp_theme", theme); } catch {}
        }, [theme]);

        const cleanupTimersRef = useRef(() => {});

        const regenerate = () => {
          const plan = buildSchedule({ firstWake, firstFeed, bedtime, feedEveryHours: feedEvery, napEveryHours: napEvery, napDurationMinutes: napDuration });
          setEvents(plan);
        };

        useEffect(() => { if (!saved) regenerate(); }, []);
        useEffect(() => { saveState({ firstWake, firstFeed, bedtime, feedEvery, napEvery, napDuration, events }); }, [firstWake, firstFeed, bedtime, feedEvery, napEvery, napDuration, events]);
        useEffect(() => {
          (async () => {
            const perm = await ensureNotificationPermission();
            setNotifStatus(perm);
            cleanupTimersRef.current();
            cleanupTimersRef.current = scheduleLocalNotifs(events);
          })();
          return () => cleanupTimersRef.current();
        }, [events]);

        const setCompleted = (idx, value) => {
          const updated = events.map((e,i)=> i===idx ? { ...e, completed: value } : e);
          setEvents(sortEvents(updated));
        };

        // Confirm now: same-type cascade; keep nap duration by shifting end with start
        const confirmNow = (idx) => {
          const actual = new Date();
          const planned = events[idx].start;
          const delta = differenceInMinutes(actual, planned);
          const updated = events.map((e, i) => {
            if (i !== idx) return e;
            if (e.type === "nap" && e.end) {
              const dur = differenceInMinutes(e.end, e.start);
              const newStart = actual;
              const newEnd = addMinutes(newStart, dur);
              return { ...e, start: newStart, end: newEnd, confirmed: true, completed: true };
            }
            return { ...e, start: actual, confirmed: true, completed: true };
          });
          setEvents(shiftFollowingSameType(updated, idx, delta));
        };

        // Nudge: same-type cascade
        const nudge = (idx, minutes) => {
          const updated = events.map((e, i) => (i === idx ? { ...e, start: addMinutes(e.start, minutes), end: e.end ? addMinutes(e.end, minutes) : undefined } : e));
          setEvents(shiftFollowingSameType(updated, idx, minutes));
        };

        const skip = (idx) => setEvents(sortEvents(events.filter((_, i) => i !== idx)));

        const isNext = (i) => { 
          const now = new Date(); 
          const nextIdx = events.findIndex(e => e.start > now && !e.completed); 
          return nextIdx === i; 
        };

        // Editable nap start/end via time-only inputs (no cascade; individual change)
        const setNapStartTime = (idx, hhmm) => {
          const updated = events.map((e,i)=> i===idx ? { ...e, start: timeToDate(e.start, hhmm) } : e);
          setEvents(sortEvents(updated));
        };
        const setNapEndTime = (idx, hhmm) => {
          const updated = events.map((e,i)=> i===idx ? { ...e, end: timeToDate(e.start, hhmm) } : e);
          setEvents(sortEvents(updated));
        };

        // Set feed ml
        const setFeedMl = (idx, ml) => {
          const updated = events.map((e,i)=> i===idx ? { ...e, ml } : e);
          setEvents(updated);
        };

        // --- Recap numbers: ONLY completed (ticked) items ---
        const completedFeeds = events.filter(e => e.type === "feed" && e.completed);
        const totalFeeds = completedFeeds.length;
        const totalMl = completedFeeds.reduce((sum, e) => sum + (e.ml ? Number(e.ml) : 0), 0);
        const completedNaps = events.filter(e => e.type === "nap" && e.completed && e.end);
        const totalNaps = completedNaps.length;
        const totalNapMinutes = completedNaps.reduce((sum, e) => sum + Math.max(0, differenceInMinutes(e.end, e.start)), 0);
        const hh = Math.floor(totalNapMinutes / 60);
        const mm = totalNapMinutes % 60;

        const downloadICS = () => {
          const ics = generateICS(events);
          const blob = new Blob([ics], { type: "text/calendar;charset=utf-8" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          const d = new Date();
          a.href = url;
          a.download = `baby-day-plan-${d.getFullYear()}${pad2(d.getMonth()+1)}${pad2(d.getDate())}.ics`;
          a.click();
          URL.revokeObjectURL(url);
        };

        const resetToday = () => {
          localStorage.removeItem("babyPlannerState");
          setEvents([]);
          const d = new Date();
          setFirstWake(clampToToday(d));
          setFirstFeed(addMinutes(clampToToday(d), 15));
          const bd = new Date(d); bd.setHours(19,0,0,0); setBedtime(bd);
          setFeedEvery(4); setNapEvery(2); setNapDuration(60);
          setTimeout(regenerate, 0);
        };

        // --- UI ---
        return React.createElement(
          "div",
          { className: "min-h-screen bg-slate-50 text-slate-800 dark:bg-slate-950 dark:text-slate-100 p-4 sm:p-6" },
          React.createElement("div", { className: "max-w-5xl mx-auto" },
            React.createElement("header", { className: "flex items-center justify-between mb-5" },
              React.createElement("h1", { className: "text-2xl sm:text-3xl font-bold" }, "Baby Day Planner"),
              React.createElement("div", { className: "flex items-center gap-3" },
                React.createElement("label", { className: "flex items-center gap-2 text-sm" },
                  React.createElement("input", {
                    type: "checkbox",
                    className: "toggle accent-slate-700 h-4 w-4",
                    checked: theme === "dark",
                    onChange: (e)=> setTheme(e.target.checked ? "dark" : "light")
                  }),
                  "Dark mode"
                ),
                React.createElement("div", { className: "text-xs text-slate-500 dark:text-slate-400" }, "Local-only â€¢ Free")
              )
            ),
            React.createElement("div", { className: "grid lg:grid-cols-2 gap-4 mb-5" },
              // Left column
              React.createElement("div", null,
                React.createElement("div", { className: "bg-white dark:bg-slate-900 rounded-2xl shadow p-4 mb-4" },
                  React.createElement("h2", { className: "font-semibold mb-3" }, "Settings"),
                  React.createElement("label", { className: "block text-sm mb-2" }, "First wake time"),
                  React.createElement("input", { className: "w-full border dark:border-slate-700 bg-white dark:bg-slate-800 rounded-xl p-2 mb-3", type: "datetime-local", value: toLocalInput(firstWake), onChange: (e) => setFirstWake(fromLocalInput(e.target.value)) }),
                  React.createElement("label", { className: "block text-sm mb-2" }, "First feed time"),
                  React.createElement("input", { className: "w-full border dark:border-slate-700 bg-white dark:bg-slate-800 rounded-xl p-2 mb-3", type: "datetime-local", value: toLocalInput(firstFeed), onChange: (e) => setFirstFeed(fromLocalInput(e.target.value)) }),
                  React.createElement("div", { className: "grid grid-cols-2 gap-3" },
                    React.createElement("div", null,
                      React.createElement("label", { className: "block text-sm mb-2" }, "Bedtime"),
                      React.createElement("input", { className: "w-full border dark:border-slate-700 bg-white dark:bg-slate-800 rounded-xl p-2 mb-3", type: "datetime-local", value: toLocalInput(bedtime), onChange: (e) => setBedtime(fromLocalInput(e.target.value)) }),
                    ),
                    React.createElement("div", null,
                      React.createElement("label", { className: "block text-sm mb-2" }, "Nap length (min)"),
                      React.createElement("input", { className: "w-full border dark:border-slate-700 bg-white dark:bg-slate-800 rounded-xl p-2 mb-3", type: "number", min: 20, max: 180, value: napDuration, onChange: (e) => setNapDuration(parseInt(e.target.value || "60", 10)) }),
                    ),
                  ),
                  React.createElement("div", { className: "grid grid-cols-2 gap-3" },
                    React.createElement("div", null,
                      React.createElement("label", { className: "block text-sm mb-2" }, "Feed every (h)"),
                      React.createElement("input", { className: "w-full border dark:border-slate-700 bg-white dark:bg-slate-800 rounded-xl p-2 mb-3", type: "number", min: 3, max: 6, value: feedEvery, onChange: (e) => setFeedEvery(parseInt(e.target.value || "4", 10)) }),
                    ),
                    React.createElement("div", null,
                      React.createElement("label", { className: "block text-sm mb-2" }, "Nap every (h)"),
                      React.createElement("input", { className: "w-full border dark:border-slate-700 bg-white dark:bg-slate-800 rounded-xl p-2 mb-3", type: "number", min: 1, max: 4, value: napEvery, onChange: (e) => setNapEvery(parseInt(e.target.value || "2", 10)) }),
                    ),
                  ),
                  React.createElement("div", { className: "flex gap-2" },
                    React.createElement("button", { className: "px-3 py-2 rounded-xl bg-slate-900 text-white", onClick: regenerate }, "Regenerate plan"),
                    React.createElement("button", { className: "px-3 py-2 rounded-xl border dark:border-slate-700", onClick: resetToday }, "Reset")
                  ),
                  React.createElement("p", { className: "text-xs text-slate-500 dark:text-slate-400 mt-3" }, "Tip: set first wake & first feed, then Regenerate.")
                ),
                React.createElement("section", { className: "bg-white dark:bg-slate-900 rounded-2xl shadow p-4" },
                  React.createElement("h2", { className: "font-semibold mb-3" }, "Today's Plan"),
                  (events.length === 0) && React.createElement("div", { className: "text-sm text-slate-600 dark:text-slate-400" }, "No items yet. Set times above and hit Regenerate."),
                  React.createElement("ul", { className: "space-y-3" },
                    events.map((e, idx) => {
                      const disabled = !!e.completed;
                      return React.createElement("li", {
                        key: e.id,
                        className: `border dark:border-slate-700 rounded-xl p-3 grid grid-cols-1 md:grid-cols-[1fr_auto] gap-3 items-center ${e.type === "feed" ? "border-indigo-200/60 bg-indigo-50/40 dark:bg-indigo-950/30" : "border-emerald-200/60 bg-emerald-50/40 dark:bg-emerald-950/30"} ${isNext(idx) ? "ring-2 ring-offset-2 ring-black/10 dark:ring-white/10 dark:ring-offset-slate-950" : ""} ${e.completed ? "opacity-60 grayscale" : ""}`
                      },
                      React.createElement("div", { className: "flex flex-col gap-2" },
                        React.createElement("div", { className: "flex items-center gap-3" },
                          React.createElement("input", { type: "checkbox", className: "h-5 w-5 accent-slate-700", checked: !!e.completed, onChange: (ev) => setCompleted(idx, ev.target.checked) }),
                          e.type === "feed"
                            ? React.createElement(React.Fragment, null,
                                React.createElement("span", { className: "chip inline-flex items-center gap-2 px-2 py-0.5 rounded-full bg-indigo-100 text-indigo-800 dark:bg-indigo-900 dark:text-indigo-100 font-semibold uppercase" }, "Feed"),
                                React.createElement("span", { className: "font-semibold text-lg" }, formatHHmm(e.start)),
                                React.createElement("div", { className: "flex items-center gap-2 ml-2" },
                                  React.createElement("span", { className: "text-xs text-slate-600 dark:text-slate-400" }, "Amount"),
                                  React.createElement("input", { type: "number", min: "0", step: "10", value: e.ml ?? "", className: "w-24 border dark:border-slate-700 bg-white dark:bg-slate-800 rounded-lg p-1 text-sm", placeholder: "ml", onChange: (ev) => setFeedMl(idx, ev.target.value === "" ? null : Math.max(0, parseInt(ev.target.value || "0", 10))), disabled })
                                )
                              )
                            : React.createElement(React.Fragment, null,
                                React.createElement("span", { className: "chip inline-flex items-center gap-2 px-2 py-0.5 rounded-full bg-emerald-100 text-emerald-800 dark:bg-emerald-900 dark:text-emerald-100 font-semibold uppercase" }, "Nap"),
                                React.createElement("div", { className: "flex items-center gap-2" },
                                  React.createElement("label", { className: "text-xs text-slate-600 dark:text-slate-400" }, "Start"),
                                  React.createElement("input", { type: "time", className: "border dark:border-slate-700 bg-white dark:bg-slate-800 rounded-lg p-1 text-sm", value: formatHHmm(e.start), onChange: (ev) => setNapStartTime(idx, ev.target.value), disabled })
                                ),
                                React.createElement("div", { className: "flex items-center gap-2" },
                                  React.createElement("label", { className: "text-xs text-slate-600 dark:text-slate-400" }, "End"),
                                  React.createElement("input", { type: "time", className: "border dark:border-slate-700 bg-white dark:bg-slate-800 rounded-lg p-1 text-sm", value: formatHHmm(e.end || addMinutes(e.start, 60)), onChange: (ev) => setNapEndTime(idx, ev.target.value), disabled })
                                )
                              )
                        ),
                        React.createElement("div", { className: "text-xs text-slate-500 dark:text-slate-400 ml-8" }, `${minutesUntil(e.start)} min from now`)
                      ),
                      React.createElement("div", { className: "flex gap-2 items-center md:justify-end" },
                        React.createElement("button", { className: "px-3 py-1.5 rounded-lg border dark:border-slate-700", onClick: () => nudge(idx, -15), disabled }, "-15m"),
                        React.createElement("button", { className: "px-3 py-1.5 rounded-lg border dark:border-slate-700", onClick: () => nudge(idx, 15), disabled }, "+15m"),
                        React.createElement("button", { className: `px-3 py-1.5 rounded-lg text-white ${e.type === "feed" ? "bg-indigo-700" : "bg-emerald-700"}`, onClick: () => confirmNow(idx), disabled }, "Confirm now"),
                        React.createElement("button", { className: "px-3 py-1.5 rounded-lg border dark:border-slate-700", onClick: () => skip(idx), disabled }, "Skip")
                      ));
                    })
                  )
                )
              ),
              // Right column: Notifications + Always-on Recap
              React.createElement("div", null,
                React.createElement("div", { className: "bg-white dark:bg-slate-900 rounded-2xl shadow p-4 mb-4" },
                  React.createElement("h2", { className: "font-semibold mb-3" }, "Notifications"),
                  React.createElement("p", { className: "text-sm text-slate-600 dark:text-slate-400" }, "Grant notifications to get on-device alerts 5 minutes before items. For reliable background alerts, export to Calendar (.ics)."),
                  React.createElement("div", { className: "mt-4" },
                    React.createElement("button", { className: "px-3 py-2 rounded-xl bg-indigo-600 text-white", onClick: downloadICS }, "Export today to Calendar (.ics)")
                  )
                ),
                React.createElement("div", { className: "bg-white dark:bg-slate-900 rounded-2xl shadow p-4" },
                  React.createElement("h2", { className: "font-semibold mb-3" }, "Daily recap (ticked only)"),
                  React.createElement("ul", { className: "space-y-2 text-sm" },
                    React.createElement("li", { className: "flex justify-between" }, React.createElement("span", { className: "text-slate-600 dark:text-slate-400" }, "Feeds (count)"), React.createElement("span", { className: "font-semibold" }, String(totalFeeds))),
                    React.createElement("li", { className: "flex justify-between" }, React.createElement("span", { className: "text-slate-600 dark:text-slate-400" }, "Milk total (ml)"), React.createElement("span", { className: "font-semibold" }, String(totalMl))),
                    React.createElement("li", { className: "flex justify-between" }, React.createElement("span", { className: "text-slate-600 dark:text-slate-400" }, "Naps (count)"), React.createElement("span", { className: "font-semibold" }, String(totalNaps))),
                    React.createElement("li", { className: "flex justify-between" }, React.createElement("span", { className: "text-slate-600 dark:text-slate-400" }, "Nap time total"), React.createElement("span", { className: "font-semibold" }, `${pad2(hh)}h ${pad2(mm)}m`)),
                  )
                )
              )
            ),
            React.createElement("footer", { className: "text-xs text-slate-500 dark:text-slate-400 mt-6" },
              "Local-only. Export to Calendar for background reminders."
            )
          )
        );
      }

      const root = ReactDOM.createRoot(document.getElementById("root"));
      root.render(React.createElement(App));
    </script>
  </body>
</html>
