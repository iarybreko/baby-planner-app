<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Baby Day Planner</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      /* prevent datetime inputs from squashing */
      input[type="datetime-local"]{min-width:210px}
    </style>
  </head>
  <body class="min-h-screen bg-slate-50 text-slate-800">
    <div id="root"></div>

    <!-- React 18 UMD -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

    <script>
      // Helpers
      const addMinutes = (d, m) => new Date(d.getTime() + m * 60000);
      const addHours = (d, h) => addMinutes(d, h * 60);
      const differenceInMinutes = (a, b) => Math.round((a.getTime() - b.getTime()) / 60000);
      const isBefore = (a, b) => a.getTime() < b.getTime();
      const startOfDay = (d) => { const x = new Date(d); x.setHours(0,0,0,0); return x; };
      const parseISO = (s) => new Date(s);
      const pad2 = (n) => String(n).padStart(2,"0");
      const formatHHmm = (d) => `${pad2(d.getHours())}:${pad2(d.getMinutes())}`;
      const formatEEE = (d) => d.toLocaleDateString(undefined, { weekday: "short" });
      const formatICS = (d) => `${d.getFullYear()}${pad2(d.getMonth()+1)}${pad2(d.getDate())}T${pad2(d.getHours())}${pad2(d.getMinutes())}${pad2(d.getSeconds())}`;

      const { useEffect, useRef, useState } = React;

      const uid = () => Math.random().toString(36).slice(2, 10);
      const toLocalInput = (d) => `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}T${pad2(d.getHours())}:${pad2(d.getMinutes())}`;
      const fromLocalInput = (s) => new Date(s);
      const clampToToday = (d) => { const today = startOfDay(new Date()); return d < today ? today : d; };
      const minutesUntil = (d) => Math.max(0, Math.round((d.getTime() - Date.now()) / 60000));
      const sortEvents = (arr) => [...arr].sort((a,b)=> a.start - b.start);

      // Build schedule
      function buildSchedule({ firstWake, firstFeed, bedtime, feedEveryHours, napEveryHours, napDurationMinutes }) {
        const events = [];
        // Feeds spaced by last START
        for (let t = new Date(firstFeed); isBefore(t, bedtime); t = addHours(t, feedEveryHours)) {
          events.push({ id: uid(), type: "feed", start: new Date(t), completed: false, ml: null });
        }
        // Naps: first at wake + napEvery, then every napEvery after previous END
        let napStart = addHours(firstWake, napEveryHours);
        let napEnd = addMinutes(napStart, napDurationMinutes);
        while (isBefore(napStart, bedtime)) {
          events.push({ id: uid(), type: "nap", start: new Date(napStart), end: new Date(napEnd), completed: false });
          napStart = addHours(napEnd, napEveryHours);
          napEnd = addMinutes(napStart, napDurationMinutes);
        }
        return sortEvents(events);
      }

      // Shift only following items of the same type by deltaMinutes
      function shiftFollowingSameType(events, index, deltaMinutes) {
        const targetType = events[index].type;
        const shifted = events.map((e, i) => {
          if (i <= index) return e;
          if (e.type !== targetType) return e;
          const start = addMinutes(e.start, deltaMinutes);
          const end = e.end ? addMinutes(e.end, deltaMinutes) : undefined;
          return { ...e, start, end };
        });
        return sortEvents(shifted);
      }

      function saveState(state) {
        localStorage.setItem("babyPlannerState", JSON.stringify({
          ...state,
          firstWake: state.firstWake.toISOString(),
          firstFeed: state.firstFeed.toISOString(),
          bedtime: state.bedtime.toISOString(),
          events: state.events.map(e => ({
            ...e,
            start: e.start.toISOString(),
            end: e.end ? e.end.toISOString() : undefined,
          })),
        }));
      }

      function loadState() {
        try {
          const raw = localStorage.getItem("babyPlannerState");
          if (!raw) return null;
          const parsed = JSON.parse(raw);
          return {
            ...parsed,
            firstWake: parseISO(parsed.firstWake),
            firstFeed: parseISO(parsed.firstFeed),
            bedtime: parseISO(parsed.bedtime),
            events: sortEvents(parsed.events.map(e => ({
              ...e,
              start: parseISO(e.start),
              end: e.end ? parseISO(e.end) : undefined,
              completed: !!e.completed,
              ml: (e.ml === undefined ? null : e.ml)
            }))),
          };
        } catch { return null; }
      }

      function ensureNotificationPermission() {
        if (!("Notification" in window)) return Promise.resolve("unsupported");
        if (Notification.permission === "granted") return Promise.resolve("granted");
        if (Notification.permission === "denied") return Promise.resolve("denied");
        return Notification.requestPermission();
      }

      function scheduleLocalNotifs(events) {
        const timers = [];
        for (const e of events) {
          if (e.completed) continue;
          const title = e.type === "feed" ? "Feed" : "Nap";
          const when = addMinutes(e.start, -5);
          const ms = when.getTime() - Date.now();
          if (ms > 0 && ms < 1000 * 60 * 60 * 24) {
            const id = window.setTimeout(() => {
              if ("Notification" in window && Notification.permission === "granted") {
                const body = `${title} at ${formatHHmm(e.start)}`;
                new Notification("Reminder", { body });
              }
            }, ms);
            timers.push(id);
          }
        }
        return () => timers.forEach(clearTimeout);
      }

      function generateICS(events) {
        const dtstamp = formatICS(new Date());
        const lines = ["BEGIN:VCALENDAR","VERSION:2.0","PRODID:-//BabyPlanner//EN"];
        for (const e of events) {
          const uidStr = `${e.id}@babyplanner`;
          const start = formatICS(e.start);
          const defaultEnd = e.type === "nap" ? addMinutes(e.start, 60) : addMinutes(e.start, 20);
          const end = formatICS(e.end || defaultEnd);
          const summary = e.type === "feed" ? "Feed" : "Nap";
          lines.push(
            "BEGIN:VEVENT",
            `UID:${uidStr}`,
            `DTSTAMP:${dtstamp}`,
            `DTSTART:${start}`,
            `DTEND:${end}`,
            `SUMMARY:${summary}`,
            "BEGIN:VALARM",
            "TRIGGER:-PT5M",
            "ACTION:DISPLAY",
            `DESCRIPTION:${summary} in 5 minutes`,
            "END:VALARM",
            "END:VEVENT"
          );
        }
        lines.push("END:VCALENDAR");
        return lines.join("\r\n");
      }

      function App() {
        const now = new Date();
        const saved = loadState();

        const [firstWake, setFirstWake] = useState(saved?.firstWake || clampToToday(now));
        const [firstFeed, setFirstFeed] = useState(saved?.firstFeed || addMinutes(clampToToday(now), 15));
        const [bedtime, setBedtime] = useState(saved?.bedtime || (() => { const d = new Date(now); d.setHours(19,0,0,0); return d; })());
        const [feedEvery, setFeedEvery] = useState(saved?.feedEvery || 4);
        const [napEvery, setNapEvery] = useState(saved?.napEvery || 2);
        const [napDuration, setNapDuration] = useState(saved?.napDuration || 60);
        const [events, setEvents] = useState(saved?.events || []);
        const [notifStatus, setNotifStatus] = useState("unknown");
        const [showRecap, setShowRecap] = useState(false);

        const cleanupTimersRef = useRef(() => {});

        const regenerate = () => {
          const plan = buildSchedule({ firstWake, firstFeed, bedtime, feedEveryHours: feedEvery, napEveryHours: napEvery, napDurationMinutes: napDuration });
          setEvents(plan);
        };

        useEffect(() => { if (!saved) regenerate(); }, []);
        useEffect(() => { saveState({ firstWake, firstFeed, bedtime, feedEvery, napEvery, napDuration, events }); }, [firstWake, firstFeed, bedtime, feedEvery, napEvery, napDuration, events]);
        useEffect(() => {
          (async () => {
            const perm = await ensureNotificationPermission();
            setNotifStatus(perm);
            cleanupTimersRef.current();
            cleanupTimersRef.current = scheduleLocalNotifs(events);
          })();
          return () => cleanupTimersRef.current();
        }, [events]);

        const setCompleted = (idx, value) => {
          const updated = events.map((e,i)=> i===idx ? { ...e, completed: value } : e);
          setEvents(sortEvents(updated));
        };

        // Confirm now: same-type cascade; keep nap duration by shifting end with start
        const confirmNow = (idx) => {
          const actual = new Date();
          const planned = events[idx].start;
          const delta = differenceInMinutes(actual, planned);
          const updated = events.map((e, i) => {
            if (i !== idx) return e;
            if (e.type === "nap" && e.end) {
              const dur = differenceInMinutes(e.end, e.start);
              const newStart = actual;
              const newEnd = addMinutes(newStart, dur);
              return { ...e, start: newStart, end: newEnd, confirmed: true, completed: true };
            }
            return { ...e, start: actual, confirmed: true, completed: true };
          });
          setEvents(shiftFollowingSameType(updated, idx, delta));
        };

        // Nudge: same-type cascade
        const nudge = (idx, minutes) => {
          const updated = events.map((e, i) => (i === idx ? { ...e, start: addMinutes(e.start, minutes), end: e.end ? addMinutes(e.end, minutes) : undefined } : e));
          setEvents(shiftFollowingSameType(updated, idx, minutes));
        };

        const skip = (idx) => setEvents(sortEvents(events.filter((_, i) => i !== idx)));

        const isNext = (i) => { 
          const now = new Date(); 
          const nextIdx = events.findIndex(e => e.start > now && !e.completed); 
          return nextIdx === i; 
        };

        // Editable nap start/end (no cascade; individual change)
        const setNapStart = (idx, dt) => {
          const updated = events.map((e,i)=> i===idx ? { ...e, start: dt } : e);
          setEvents(sortEvents(updated));
        };
        const setNapEnd = (idx, dt) => {
          const updated = events.map((e,i)=> i===idx ? { ...e, end: dt } : e);
          setEvents(sortEvents(updated));
        };

        // Set feed ml
        const setFeedMl = (idx, ml) => {
          const updated = events.map((e,i)=> i===idx ? { ...e, ml } : e);
          setEvents(updated);
        };

        // --- Recap numbers: ONLY completed (ticked) items ---
        const completedFeeds = events.filter(e => e.type === "feed" && e.completed);
        const totalFeeds = completedFeeds.length;
        const totalMl = completedFeeds.reduce((sum, e) => sum + (e.ml ? Number(e.ml) : 0), 0);
        const completedNaps = events.filter(e => e.type === "nap" && e.completed && e.end);
        const totalNapMinutes = completedNaps.reduce((sum, e) => sum + Math.max(0, differenceInMinutes(e.end, e.start)), 0);
        const hh = Math.floor(totalNapMinutes / 60);
        const mm = totalNapMinutes % 60;

        const downloadICS = () => {
          const ics = generateICS(events);
          const blob = new Blob([ics], { type: "text/calendar;charset=utf-8" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          const d = new Date();
          a.href = url;
          a.download = `baby-day-plan-${d.getFullYear()}${pad2(d.getMonth()+1)}${pad2(d.getDate())}.ics`;
          a.click();
          URL.revokeObjectURL(url);
        };

        const resetToday = () => {
          localStorage.removeItem("babyPlannerState");
          setEvents([]);
          const d = new Date();
          setFirstWake(clampToToday(d));
          setFirstFeed(addMinutes(clampToToday(d), 15));
          const bd = new Date(d); bd.setHours(19,0,0,0); setBedtime(bd);
          setFeedEvery(4); setNapEvery(2); setNapDuration(60);
          setTimeout(regenerate, 0);
        };

        // --- UI ---
        return React.createElement(
          "div",
          { className: "min-h-screen bg-slate-50 text-slate-800 p-4 sm:p-6" },
          React.createElement("div", { className: "max-w-3xl mx-auto" },
            React.createElement("header", { className: "flex items-center justify-between mb-6" },
              React.createElement("h1", { className: "text-2xl sm:text-3xl font-bold" }, "Baby Day Planner"),
              React.createElement("div", { className: "flex items-center gap-2" },
                React.createElement("button", { className: "px-3 py-2 rounded-xl border", onClick: () => setShowRecap(true) }, "Daily recap"),
                React.createElement("div", { className: "text-xs text-slate-500" }, "Local-only • Free • No sign-up")
              )
            ),
            React.createElement("div", { className: "grid sm:grid-cols-2 gap-4 mb-6" },
              React.createElement("div", { className: "bg-white rounded-2xl shadow p-4" },
                React.createElement("h2", { className: "font-semibold mb-3" }, "Settings"),
                React.createElement("label", { className: "block text-sm mb-2" }, "First wake time"),
                React.createElement("input", { className: "w-full border rounded-xl p-2 mb-3", type: "datetime-local", value: toLocalInput(firstWake), onChange: (e) => setFirstWake(fromLocalInput(e.target.value)) }),
                React.createElement("label", { className: "block text-sm mb-2" }, "First feed time"),
                React.createElement("input", { className: "w-full border rounded-xl p-2 mb-3", type: "datetime-local", value: toLocalInput(firstFeed), onChange: (e) => setFirstFeed(fromLocalInput(e.target.value)) }),
                React.createElement("div", { className: "grid grid-cols-2 gap-3" },
                  React.createElement("div", null,
                    React.createElement("label", { className: "block text-sm mb-2" }, "Bedtime"),
                    React.createElement("input", { className: "w-full border rounded-xl p-2 mb-3", type: "datetime-local", value: toLocalInput(bedtime), onChange: (e) => setBedtime(fromLocalInput(e.target.value)) }),
                  ),
                  React.createElement("div", null,
                    React.createElement("label", { className: "block text-sm mb-2" }, "Nap length (min)"),
                    React.createElement("input", { className: "w-full border rounded-xl p-2 mb-3", type: "number", min: 20, max: 180, value: napDuration, onChange: (e) => setNapDuration(parseInt(e.target.value || "60", 10)) }),
                  ),
                ),
                React.createElement("div", { className: "grid grid-cols-2 gap-3" },
                  React.createElement("div", null,
                    React.createElement("label", { className: "block text-sm mb-2" }, "Feed every (h)"),
                    React.createElement("input", { className: "w-full border rounded-xl p-2 mb-3", type: "number", min: 3, max: 6, value: feedEvery, onChange: (e) => setFeedEvery(parseInt(e.target.value || "4", 10)) }),
                  ),
                  React.createElement("div", null,
                    React.createElement("label", { className: "block text-sm mb-2" }, "Nap every (h)"),
                    React.createElement("input", { className: "w-full border rounded-xl p-2 mb-3", type: "number", min: 1, max: 4, value: napEvery, onChange: (e) => setNapEvery(parseInt(e.target.value || "2", 10)) }),
                  ),
                ),
                React.createElement("div", { className: "flex gap-2" },
                  React.createElement("button", { className: "px-3 py-2 rounded-xl bg-slate-900 text-white", onClick: regenerate }, "Regenerate plan"),
                  React.createElement("button", { className: "px-3 py-2 rounded-xl border", onClick: resetToday }, "Reset")
                ),
                React.createElement("p", { className: "text-xs text-slate-500 mt-3" }, "Tip: set first wake & first feed, then Regenerate. Adjust on the fly with Confirm/Delay.")
              ),
              React.createElement("div", { className: "bg-white rounded-2xl shadow p-4" },
                React.createElement("h2", { className: "font-semibold mb-3" }, "Notifications"),
                (notifStatus === "unsupported") && React.createElement("p", { className: "text-sm text-amber-700" }, "Notifications not supported in this browser."),
                (notifStatus === "denied") && React.createElement("p", { className: "text-sm text-amber-700" }, "Notifications are blocked. Enable them in your browser settings."),
                (notifStatus === "granted") && React.createElement("p", { className: "text-sm text-emerald-700" }, "On-device alerts set 5 minutes before each upcoming item (while the app is open)."),
                (notifStatus === "unknown") && React.createElement("p", { className: "text-sm text-slate-600" }, "You'll be prompted to allow notifications."),
                React.createElement("div", { className: "mt-4" },
                  React.createElement("button", { className: "px-3 py-2 rounded-xl bg-indigo-600 text-white", onClick: downloadICS }, "Export today to Calendar (.ics)"),
                  React.createElement("p", { className: "text-xs text-slate-500 mt-2" }, "For reliable phone alerts, add the events to your device calendar. Includes 5-minute reminders.")
                )
              )
            ),
            React.createElement("section", { className: "bg-white rounded-2xl shadow p-4" },
              React.createElement("h2", { className: "font-semibold mb-3" }, "Today's Plan"),
              (events.length === 0) && React.createElement("div", { className: "text-sm text-slate-600" }, "No items yet. Set times above and hit Regenerate."),
              React.createElement("ul", { className: "space-y-3" },
                events.map((e, idx) => {
                  const disabled = !!e.completed;
                  return React.createElement("li", {
                    key: e.id,
                    className: `border rounded-xl p-3 grid grid-cols-1 md:grid-cols-[1fr_auto] gap-3 items-start ${e.type === "feed" ? "border-indigo-200 bg-indigo-50/50" : "border-emerald-200 bg-emerald-50/50"} ${isNext(idx) ? "ring-2 ring-offset-2 ring-black/10" : ""} ${e.completed ? "opacity-60 grayscale" : ""}`
                  },
                  React.createElement("div", { className: "flex gap-3 items-start" },
                    React.createElement("input", {
                      type: "checkbox",
                      className: "mt-1 h-5 w-5 accent-slate-700",
                      checked: !!e.completed,
                      onChange: (ev) => setCompleted(idx, ev.target.checked)
                    }),
                    e.type === "feed"
                      ? React.createElement("div", null,
                          React.createElement("div", { className: "flex items-center gap-2" },
                            React.createElement("span", { className: "text-xs font-semibold tracking-wide uppercase mb-1 inline-flex items-center gap-2 px-2 py-0.5 rounded-full bg-indigo-100 text-indigo-800" }, "Feed"),
                            React.createElement("span", { className: `font-semibold text-lg ${e.completed ? "line-through" : ""}` }, `${formatEEE(e.start)} ${formatHHmm(e.start)}`)
                          ),
                          React.createElement("div", { className: "mt-1 flex items-center gap-2" },
                            React.createElement("label", { className: "text-xs text-slate-600" }, "Amount (ml)"),
                            React.createElement("input", {
                              type: "number",
                              min: "0",
                              step: "10",
                              value: e.ml ?? "",
                              className: "w-24 border rounded-lg p-1 text-sm",
                              placeholder: "e.g. 120",
                              onChange: (ev) => setFeedMl(idx, ev.target.value === "" ? null : Math.max(0, parseInt(ev.target.value || "0", 10))),
                              disabled
                            })
                          ),
                          React.createElement("div", { className: "text-xs text-slate-500 mt-1" }, `${minutesUntil(e.start)} min from now`)
                        )
                      : React.createElement("div", null,
                          React.createElement("div", { className: "text-xs font-semibold tracking-wide uppercase mb-1 inline-flex items-center gap-2 px-2 py-0.5 rounded-full bg-emerald-100 text-emerald-800" }, "Nap"),
                          React.createElement("div", { className: "flex flex-col sm:flex-row sm:items-center gap-2" },
                            React.createElement("div", { className: "flex items-center gap-2" },
                              React.createElement("label", { className: "text-xs text-slate-600" }, "Start"),
                              React.createElement("input", {
                                type: "datetime-local",
                                className: "border rounded-lg p-1 text-sm",
                                value: toLocalInput(e.start),
                                onChange: (ev) => {
                                  const dt = fromLocalInput(ev.target.value);
                                  const end = e.end && e.end < dt ? addMinutes(dt, 60) : e.end;
                                  setNapStart(idx, dt);
                                  if (end && end < dt) setNapEnd(idx, addMinutes(dt, 60));
                                },
                                disabled
                              })
                            ),
                            React.createElement("div", { className: "flex items-center gap-2" },
                              React.createElement("label", { className: "text-xs text-slate-600" }, "End"),
                              React.createElement("input", {
                                type: "datetime-local",
                                className: "border rounded-lg p-1 text-sm",
                                value: toLocalInput(e.end || addMinutes(e.start, 60)),
                                onChange: (ev) => {
                                  const dt = fromLocalInput(ev.target.value);
                                  if (dt <= e.start) {
                                    setNapEnd(idx, addMinutes(e.start, 10)); // minimum 10m
                                  } else {
                                    setNapEnd(idx, dt);
                                  }
                                },
                                disabled
                              })
                            )
                          ),
                          React.createElement("div", { className: "text-xs text-slate-500 mt-1" }, `${minutesUntil(e.start)} min from now`)
                        )
                  ),
                  React.createElement("div", { className: "flex gap-2 items-center md:justify-end" },
                    React.createElement("button", { className: "px-3 py-1.5 rounded-lg border", onClick: () => nudge(idx, -15), disabled }, "-15m"),
                    React.createElement("button", { className: "px-3 py-1.5 rounded-lg border", onClick: () => nudge(idx, 15), disabled }, "+15m"),
                    React.createElement("button", { className: `px-3 py-1.5 rounded-lg text-white ${e.type === "feed" ? "bg-indigo-700" : "bg-emerald-700"}`, onClick: () => confirmNow(idx), disabled }, "Confirm now"),
                    React.createElement("button", { className: "px-3 py-1.5 rounded-lg border", onClick: () => skip(idx), disabled }, "Skip")
                  ));
                })
              )
            ),
            React.createElement("footer", { className: "text-xs text-slate-500 mt-6" },
              "Notes: This planner keeps data on your device only. Local notifications fire while the app is open. For background alerts, export to Calendar. Adjust intervals as your baby transitions."
            )
          ),

          // Recap Modal
          showRecap && React.createElement("div", { className: "fixed inset-0 bg-black/40 flex items-center justify-center z-50" },
            React.createElement("div", { className: "bg-white rounded-2xl shadow-xl p-5 w-[90vw] max-w-md" },
              React.createElement("div", { className: "flex items-center justify-between mb-3" },
                React.createElement("h3", { className: "text-lg font-semibold" }, "Daily recap (ticked only)"),
                React.createElement("button", { className: "text-sm px-2 py-1 rounded-lg border", onClick: () => setShowRecap(false) }, "Close")
              ),
              React.createElement("div", { className: "space-y-2 text-sm" },
                React.createElement("div", { className: "flex justify-between" },
                  React.createElement("span", { className: "text-slate-600" }, "Feeds (count)"),
                  React.createElement("span", { className: "font-semibold" }, String(totalFeeds))
                ),
                React.createElement("div", { className: "flex justify-between" },
                  React.createElement("span", { className: "text-slate-600" }, "Milk total (ml)"),
                  React.createElement("span", { className: "font-semibold" }, String(totalMl))
                ),
                React.createElement("div", { className: "flex justify-between" },
                  React.createElement("span", { className: "text-slate-600" }, "Nap time total"),
                  React.createElement("span", { className: "font-semibold" }, `${pad2(hh)}h ${pad2(mm)}m`)
                ),
              ),
              React.createElement("p", { className: "text-xs text-slate-500 mt-3" }, "Tick a feed/nap to include it here. Untick to remove.")
            )
          )
        );
      }

      const root = ReactDOM.createRoot(document.getElementById("root"));
      root.render(React.createElement(App));
    </script>
  </body>
</html>
